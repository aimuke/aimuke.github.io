---
title: "算法的时间复杂度"
tags: [algorithm, complexity, "时间复杂度", todo]
---

**raymondCaptain 2017.11.02**

# 概念

我们假设计算机运行一行基础代码需要执行一次运算。

```js
int aFunc(void) {
    printf("Hello, World!\n");      //  需要执行 1 次
    return 0;       // 需要执行 1 次
}
```
那么上面这个方法需要执行 2 次运算
```js
int aFunc(int n) {
    for(int i = 0; i<n; i++) {         // 需要执行 (n + 1) 次
        printf("Hello, World!\n");      // 需要执行 n 次
    }
    return 0;       // 需要执行 1 次
}
```
这个方法需要 `(n + 1 + n + 1) = 2n + 2` 次运算。

**时间复杂度:** 用来定性的描述算法的执行时间的一个函数,更类似于一个耗时的趋势,函数表示为: O(f(n))

**名词解释:**
- n: 问题的规模,重复执行的次数
- T(n): 一段程序运行,各种操作代码所执行的总次数
- f(n): 存在的某个函数,使得T(n)/f(n)=非零常数,	那么f(n)称为T(n)的同数量级函数
- O: 大O符号,一种符号,表示渐进于无穷的行为

穿起来:

算法中各种代码操作所执行的总次数用 `T(n)` 表示,存在某个函数 `f(n)` ,使得 `T(n)/f(n)=非零常数` ,那么 `f(n)` 称为 `T(n)` 的同数量级函数(类想一下,在坐标轴中,当入参n趋于无穷时,两条曲线的商为常数),即: `T(n)=O(f(n))`,`O(f(n))` 就是时间复杂度. `O` 符号表示一个渐进常数. 

常规的代码的算法是有规律的:
- 看几重循环:只有一重则时间复杂度为`O(n)`，二重为`O(n^2)`;
- 如果有二分则为 `O(logn)`，二分例如快速幂、二分查找，
- 如果一个for循环套一个二分，那么时间复杂度则为 `O(nlogn)`。

常见时间复杂度有(按增长率):
1. 常数阶 `O(1)`
2. 对数阶 `O(logn)`
3. 线性阶 `O(n)`
4. 线性对数阶`O(nlog2n)`
5. k方阶: `O(n^k)`,一般控制 `k` 的大小,否则就和指数阶一样了,这是很可怕的
6. 指数阶: `O(2^n)`,一般不用,性能太差

# 计算规则
那么当我们拿到算法的执行次数函数 `T(n)` 之后怎么得到算法的时间复杂度呢？

## 省略常数项
我们知道常数项对函数的增长速度影响并不大，所以当 `T(n) = c`，`c` 为一个常数的时候，我们说这个算法的时间复杂度为 `O(1)`；如果 `T(n)` 不等于一个常数项时，直接将常数项省略。

比如第一个 `Hello, World` 的例子中 `T(n) = 2`，所以我们说那个函数(算法)的时间复杂度为 `O(1)`。`T(n) = n + 29`，此时时间复杂度为 `O(n)`。

## 忽略低次项
我们知道高次项对于函数的增长速度的影响是最大的。`n^3` 的增长速度是远超 `n^2` 的，同时 `n^2` 的增长速度是远超 `n` 的。 同时因为要求的精度不高，所以我们直接忽略低此项。

比如 `T(n) = n^3 + n^2 + 29` ，此时时间复杂度为 `O(n^3)`。

## 忽略高阶常数
因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数。

比如 `T(n) = 3n^3`，此时时间复杂度为 `O(n^3)`。

**综合起来：** 如果一个算法的执行次数是 `T(n)`，那么只保留最高次项，同时忽略最高项的系数后得到函数 `f(n)`，此时算法的时间复杂度就是 `O(f(n))`。为了方便描述，下文称此为 **大O推导法**。

# 常见场景

由此可见，由执行次数 T(n) 得到时间复杂度并不困难，很多时候困难的是从算法通过分析和数学运算得到 T(n)。对此，提供下列四个便利的法则，这些法则都是可以简单推导出来的，总结出来以便提高效率。

## 简单循环
对于一个循环，假设循环体的时间复杂度为 `O(n)`，循环次数为 `m`，则这个
循环的时间复杂度为 `O(n×m)`。

```js
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
    }
}
```
此时时间复杂度为 `O(n × 1)`，即 `O(n)`。

## 多重循环
对于多个循环，假设循环体的时间复杂度为 `O(n)`，各个循环的循环次数分别是`a, b, c...`，则这个循环的时间复杂度为 `O(n×a×b×c...)`。分析的时候应该由里向外分析这些循环。

```js
void aFunc(int n) {
    for(int i = 0; i < n; i++) {         // 循环次数为 n
        for(int j = 0; j < n; j++) {       // 循环次数为 n
            printf("Hello, World!\n");      // 循环体时间复杂度为 O(1)
        }
    }
}
```
此时时间复杂度为 `O(n × n × 1)`，即 `O(n^2)`。

## 多个并列循环

对于顺序执行的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

```js
void aFunc(int n) {
    // 第一部分时间复杂度为 O(n^2)
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            printf("Hello, World!\n");
        }
    }
    // 第二部分时间复杂度为 O(n)
    for(int j = 0; j < n; j++) {
        printf("Hello, World!\n");
    }
}
```

此时时间复杂度为 `max(O(n^2), O(n))`，即 `O(n^2)`。

## 条件判断
对于条件判断语句，总的时间复杂度等于其中时间复杂度最大的路径的时间复杂度。
```js
void aFunc(int n) {
    if (n >= 0) {
        // 第一条路径时间复杂度为 O(n^2)
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                printf("输入数据大于等于零\n");
            }
        }
    } else {
        // 第二条路径时间复杂度为 O(n)
        for(int j = 0; j < n; j++) {
            printf("输入数据小于零\n");
        }
    }
}
```
此时时间复杂度为 `max(O(n^2), O(n))`，即 `O(n^2)`。

时间复杂度分析的基本策略是：**从内向外分析，从最深层开始分析。如果遇到函数调用，要深入函数进行分析**。

# 示例
最后，我们来练习一下

## 基础题
求该方法的时间复杂度
```js
void aFunc(int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i; j < n; j++) {
            printf("Hello World\n");
        }
    }
}
```
参考答案：

当 `i = 0` 时，内循环执行 `n` 次运算，当 `i = 1 `时，内循环执行 `n - 1` 次运算……当 `i = n - 1` 时，内循环执行 `1` 次运算。
所以，执行次数 `T(n) = n + (n - 1) + (n - 2)……+ 1 = n(n + 1) / 2 = n^2 / 2 + n / 2`。
根据上文说的 **大O推导法** 可以知道，此时时间复杂度为 `O(n^2)`。

## 进阶题
求该方法的时间复杂度
```js
void aFunc(int n) {
    for (int i = 2; i < n; ) {
        i *= 2;
        printf("%i\n", i);
    }
}
```
参考答案：

假设循环次数为 `t`，则循环条件满足 `2^t < n`。
可以得出，执行次数`t = log(2)(n)`，即 `T(n) = log(2)(n)`，可见时间复杂度为 `O(log(2)(n))`，即 `O(log n)`。

## 再次进阶
求该方法的时间复杂度
```js
long aFunc(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return aFunc(n - 1) + aFunc(n - 2);
    }
}
```
参考答案：

显然运行次数，`T(0) = T(1) = 1`，同时 `T(n) = T(n - 1) + T(n - 2) + 1`，这里的 `1` 是其中的加法算一次执行。

显然 `T(n) = T(n - 1) + T(n - 2)` 是一个斐波那契数列，通过归纳证明法可以证明，当 `n >= 1` 时 `T(n) < (5/3)^n`，同时当 `n > 4` 时 `T(n) >= (3/2)^n`。

所以该方法的时间复杂度可以表示为 `O((5/3)^n)`，简化后为 `O(2^n)`。

可见这个方法所需的运行时间是以指数的速度增长的。如果大家感兴趣，可以试下分别用 1，10，100 的输入大小来测试下算法的运行时间，相信大家会感受到时间复杂度的无穷魅力。

# 参考文献

- [原文地址](https://www.jianshu.com/p/f4cca5ce055a)

- [概念介绍](https://blog.csdn.net/weixin_40533111/article/details/83027707)
