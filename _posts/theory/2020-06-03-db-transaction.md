---
title: "数据库事务"
tags: [db, transaction]
---

# 事物
> 事务(Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。在计算机术语中，事务通常就是指数据库事务。

## 概念
一个数据库事务通常包含对数据库进行读或写的一个操作序列。它的存在包含有以下两个目的：

1. 为数据库操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
2. 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

当一个事务被提交给了DBMS（数据库管理系统），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态（要么全执行，要么全都不执行）;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

## 特性ACID
并非任意的对数据库的操作序列都是数据库事务。事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。

- 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
- 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
- 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
- 持久性（Durability）：一个事务一旦提交，他对数据库的修改应该永久保存在数据库中。

## 举例
用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

1. 从A账号中把余额读出来（500）
2. 对A账号做减法操作（500-100）
3. 把结果写回A账号中（400）
4. 从B账号中把余额读出来（500）
5. 对B账号做加法操作（500+100）
6. 把结果写回B账号中（600）

**原子性**
保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。

**一致性**
在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。

**隔离性**
在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。

**持久性**
一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）！

## 原子性与隔离行
一致性与原子性是密切相关的,原子性的破坏可能导致数据库的不一致，数据的一致性问题并不都和原子性有关。
比如刚刚的例子，在第五步的时候，对B账户做加法时只加了50元。那么该过程可以符合原子性，但是数据的一致性就出现了问题。

因此，事务的原子性与一致性缺一不可。

# 隔离等级

> 本章详细介绍四种事务隔离级别，并通过举例的方式说明不同的级别能解决什么样的读现象。并且介绍了在关系型数据库中不同的隔离级别的实现原理。

在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足久性。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生[脏读](#脏读)、[不可重复读](#不可重复读)或者[幻读](#幻读)等读现象。

在数据库事务的`[ACID](#特性ACID)`四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。


在软件开发中，几乎每类这样的问题都会有多种最佳实践来供我们参考，很多DBMS定义了多个不同的“事务隔离等级”来控制锁的程度和并发能力。

ANSI/ISO SQL定义的标准隔离级别有四种，**从高到底依次为**：
- 可序列化(Serializable)
- 可重复读(Repeatable reads)
- 提交读(Read committed)
- 未提交读(Read uncommitted)

下面将依次介绍这四种事务隔离级别的概念、用法以及解决了哪些问题（读现象）
## 未提交读
未提交读(READ UNCOMMITTED)是最低的隔离级别。通过名字我们就可以知道，在这种事务隔离级别下，一个事务可以读到另外一个事务未提交的数据。

### 未提交读的数据库锁情况（实现原理）

> 事务在读数据的时候并未对数据加锁。
> 
>事务在修改数据的时候只对数据增加行级共享锁。

### 现象

> 事务1读取某行记录时，事务2也能对这行记录进行读取、更新（因为事务一并未对数据增加任何锁）
>
> 当事务2对该记录进行更新时，事务1再次读取该记录，能读到事务2对该记录的修改版本（因为事务二只增加了共享读锁，事务一可以再增加共享读锁读取数据），即使该修改尚未被提交。
>
> 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（因为事务一对数据增加了共享读锁，事务二不能增加排他写锁进行数据的修改）

### 举例
下面还是借用我在数据库的读现象浅析一文中举的例子来说明在未提交读的隔离级别中两个事务之间的隔离情况。

<table>
    <thead><tr><td style="border:1px solid">事物一</td><td style="border:1px solid">事物二</td></tr>
    </thead>
    <tbody>
    <tr>
        <td style="border:1px solid">
        <pre lang="sql">/* Query 1 */
SELECT age FROM users WHERE id = 1;
/* will read 20 */</pre>
        </td><td style="border:1px solid"></td>
    </tr>
    <tr>
        <td style="border:1px solid"></td><td style="border:1px solid">
    <pre>/* Query 2 */ 
    UPDATE users SET age = 21 WHERE id = 1;
    /* No commit here */</pre>
        </td>
    </tr>
    <tr>
        <td style="border:1px solid">
            <pre>
/* Query 1 */
SELECT age FROM users WHERE id = 1;
/* will read 21 */</pre>
        </td><td style="border:1px solid"></td>
    </tr>
    <tr>
        <td style="border:1px solid"></td><td style="border:1px solid">
        <pre>ROLLBACK;
/* lock-based DIRTY READ */</pre>
    </td>
    </tr>
    </tbody>
</table>

事务一共查询了两次，在两次查询的过程中，事务二对数据进行了修改，并未提交（commit）。但是事务一的第二次查询查到了事务二的修改结果。在数据库的读现象浅析中我们介绍过，这种现象我们称之为脏读。

所以，**未提交读会导致`[脏读](#脏读)`**

## 提交读
提交读(READ COMMITTED)也可以翻译成读已提交，通过名字也可以分析出，在一个事务修改数据过程中，如果事务还没提交，其他事务不能读该数据。

### 提交读的数据库锁情况
> 事务对当前被读取的数据加 行级共享锁（当读到时才加锁），一旦读完该行，立即释放该行级共享锁；
> 
> 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

### 现象：

> 事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。
> 
> 事务1读取某行的一瞬间，事务2不能修改该行数据，但是，只要事务1读取完改行数据，事务2就可以对该行数据进行修改。（事务一在读取的一瞬间会对数据增加共享锁，任何其他事务都不能对该行数据增加排他锁。但是事务一只要读完该行数据，就会释放行级共享锁，一旦锁释放，事务二就可以对数据增加排他锁并修改数据）
> 
> 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）

### 举例
<table>
    <thead>
        <tr><td>事物一</td><td>事物二</td></tr>
    </thead>
    <tbody>
        <tr>
            <td>
            <pre>/* Query 1 */

SELECT * FROM users WHERE id = 1;</pre>
            </td><td></td>
        </tr>
        <tr>
            <td></td><td><pre>/* Query 2 */ 
UPDATE users SET age = 21 WHERE id = 1;
COMMIT;
/* in multiversion concurrency
control, or lock-based READ COMMITTED */</pre></td>
        </tr>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users WHERE id = 1;
COMMIT; 
/*lock-based REPEATABLE READ */	</pre></td><td></td>
        </tr>
    </tbody>
</table>

在提交读隔离级别中，在事务二提交之前，事务一不能读取数据。只有在事务二提交之后，事务一才能读数据。

但是从上面的例子中我们也看到，事务一两次读取的结果并不一致，**所以提交读不能解决[不可重复读](#不可重复读)的读现象。**

简而言之，提交读这种隔离级别保证了读到的任何数据都是提交的数据，避免了[脏读(dirty reads)](#脏读)。但是不保证事务重新读的时候能读到相同的数据，因为在每次数据读完之后其他事务可以修改刚才读到的数据。

## 可重复读
可重复读(REPEATABLE READS),由于提交读隔离级别会产生不可重复读的读现象。所以，比提交读更高一个级别的隔离级别就可以解决不可重复读的问题。这种隔离级别就叫可重复读（这名字起的是不是很任性！！）

### 可重复读的数据库锁情况
> 事务在读取某数据的瞬间（就是开始读取的瞬间），必须先对其加 行级共享锁，直到事务结束才释放；
>
> 事务在更新某数据的瞬间（就是发生更新的瞬间），必须先对其加 行级排他锁，直到事务结束才释放。

### 现象

> 事务1在读取某行记录的整个过程中，事务2都可以对该行记录进行读取（因为事务一对该行记录增加行级共享锁的情况下，事务二同样可以对该数据增加共享锁来读数据。）。
>
>事务1在读取某行记录的整个过程中，事务2都不能修改该行数据（事务一在读取的整个过程会对数据增加共享锁，直到事务提交才会释放锁，所以整个过程中，任何其他事务都不能对该行数据增加排他锁。所以，可重复读能够解决不可重复读的读现象）
>
> 事务1更新某行记录时，事务2不能对这行记录做更新，直到事务1结束。（事务一在更新数据的时候，会对该行数据增加排他锁，知道事务结束才会释放锁，所以，在事务二没有提交之前，事务一都能不对数据增加共享锁进行数据的读取。所以，提交读可以解决脏读的现象）

### 举例
<table>
    <thead>
        <tr>
            <td>事务一</td><td>事务二</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users WHERE id = 1;
COMMIT;</pre></td><td></td>
        </tr>
        <tr>
            <td></td><td><pre>/* Query 2 */ 
UPDATE users SET age = 21 WHERE id = 1;
COMMIT;
/* in multiversion concurrency
control, or lock-based READ COMMITTED */</pre></td>
        </tr>
    </tbody>
</table>

在上面的例子中，只有在事务一提交之后，事务二才能更改该行数据。所以，只要在事务一从开始到结束的这段时间内，无论他读取该行数据多少次，结果都是一样的。

从上面的例子中我们可以得到结论：可重复读隔离级别可以解决[不可重复读](#不可重复读)的读现象。**但是可重复读这种隔离级别中，还有另外一种读现象他解决不了，那就是[幻读](#幻读)**。看下面的例子：
<table>
    <thead>
        <tr>
            <td>事务一</td><td>事务二</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><pre>/* Query 1 */

SELECT * FROM users
WHERE age BETWEEN 10 AND 30;</pre></td><td></td>
        </tr>
        <tr>
            <td></td><td><pre>/* Query 2 */ 
INSERT INTO users VALUES ( 3, 'Bob', 27 );
COMMIT;</pre></td>
        </tr>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users
WHERE age BETWEEN 10 AND 30;</pre></td><td></td>
        </tr>
    </tbody>
</table>
	
上面的两个事务执行情况及现象如下：

1. 事务一的第一次查询条件是`age BETWEEN 10 AND 30;`如果这是有十条记录符合条件。这时，他会给符合条件的这十条记录增加行级共享锁。任何其他事务无法更改这十条记录。

2. 事务二执行一条sql语句，语句的内容是向表中插入一条数据。因为此时没有任何事务对表增加表级锁，所以，该操作可以顺利执行。

3. 事务一再次执行`SELECT * FROM users WHERE age BETWEEN 10 AND 30;`时，结果返回的记录变成了十一条，比刚刚增加了一条，增加的这条正是事务二刚刚插入的那条。

所以，事务一的两次范围查询结果并不相同。这也就是我们提到的[幻读](#幻读)。

## 可序列化
可序列化(Serializable)是最高的隔离级别，前面提到的所有的隔离级别都无法解决的幻读，在可序列化的隔离级别中可以解决。

我们说过，产生幻读的原因是事务一在进行范围查询的时候没有增加范围锁(range-locks：给SELECT 的查询中使用一个“WHERE”子句描述范围加锁），所以导致幻读。

### 可序列化的数据库锁情况
> 事务在读取数据时，必须先对其加 表级共享锁 ，直到事务结束才释放；
> 
> 事务在更新数据时，必须先对其加 表级排他锁 ，直到事务结束才释放。

### 现象

> 事务1正在读取A表中的记录时，则事务2也能读取A表，但不能对A表做更新、新增、删除，直到事务1结束。(因为事务一对表增加了表级共享锁，其他事务只能增加共享锁读取数据，不能进行其他任何操作）
>
> 事务1正在更新A表中的记录时，则事务2不能读取A表的任意记录，更不可能对A表做更新、新增、删除，直到事务1结束。（事务一对表增加了表级排他锁，其他事务不能对表增加共享锁或排他锁，也就无法进行任何操作）

虽然可序列化解决了脏读、不可重复读、幻读等读现象。但是序列化事务会产生以下效果：

1. 无法读取其它事务已修改但未提交的记录。

2. 在当前事务完成之前，其它事务不能修改目前事务已读取的记录。

3. 在当前事务完成之前，其它事务所插入的新记录，其索引键值不能在当前事务的任何语句所读取的索引键范围中。

四种事务隔离级别从隔离程度上越来越高，但同时在并发性上也就越来越低。之所以有这么几种隔离级别，就是为了方便开发人员在开发过程中根据业务需要选择最合适的隔离级别。


# 数据库读现象
“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。

## 脏读
脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的。

脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交(commit)到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。

**举例说明：**

在下面的例子中，事务2修改了一行，但是没有提交，事务1读了这个没有提交的数据。现在如果事务2回滚了刚才的修改或者做了另外的修改的话，事务1中查到的数据就是不正确的了。
<table>
    <thead>
        <tr>
            <td>事务一</td> <td>事务二</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><pre>/* Query 1 */
SELECT age FROM users WHERE id = 1;
/* will read 20 */	</pre></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><pre>/* Query 2 */ 
UPDATE users SET age = 21 WHERE id = 1;
/* No commit here */</pre></td>
        </tr>
        <tr>
            <td><pre>/* Query 1 */
SELECT age FROM users WHERE id = 1;
/* will read 21 */	
ROLLBACK;
/* lock-based DIRTY READ */</pre></td>
            <td></td>
        </tr>
    </tbody>
</table>

在这个例子中，事务2回滚后就没有id是1，age是21的数据了。所以，事务一读到了一条脏数据。

## 不可重复读
不可重复读，是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。

一种更易理解的说法是：在一个事务内，多次读同一个数据。在这个事务还没有结束时，另一个事务也访问该同一数据。那么，在第一个事务的两次读数据之间。由于第二个事务的修改，那么第一个事务读到的数据可能不一样，这样就发生了在一个事务内两次读到的数据是不一样的，因此称为不可重复读，即原始读取不可重复。

**举例说明：**

在基于锁的并发控制中“不可重复读(non-repeatable read)”现象发生在当执行SELECT 操作时没有获得读锁(read locks)或者SELECT操作执行完后马上释放了读锁； 多版本并发控制中当没有要求一个提交冲突的事务回滚也会发生“不可重复读(non-repeatable read)”现象。

<table>
    <thead>
        <tr>
            <td>事务一</td> <td>事务二</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users WHERE id = 1;</pre></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><pre>/* Query 2 */ 
UPDATE users SET age = 21 WHERE id = 1;

COMMIT;

/* in multiversion concurrency
control, or lock-based READ COMMITTED */</pre></td>
        </tr>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users WHERE id = 1;
COMMIT; 
/*lock-based REPEATABLE READ */	</pre></td>
            <td></td>
        </tr>
    </tbody>
</table>

在这个例子中，事务2提交成功，因此他对id为1的行的修改就对其他事务可见了。但是事务1在此前已经从这行读到了另外一个“age”的值。

## 幻读
幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.一般解决幻读的方法是增加范围锁RangeS，锁定检锁范围为只读，这样就避免了幻读。　　

> 幻读(phantom read)”是不可重复读(Non-repeatable reads)的一种特殊场景：当事务没有获取范围锁的情况下执行SELECT … WHERE操作可能会发生“幻影读(phantom read)”。

**举例说明：**

当事务1两次执行SELECT … WHERE检索一定范围内数据的操作中间，事务2在这个表中创建了(如INSERT)了一行新数据，这条新数据正好满足事务1的“WHERE”子句。

<table>
    <thead>
        <tr>
            <td>事务一</td> <td>事务二</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users
WHERE age BETWEEN 10 AND 30;
</pre></td>
            <td></td>
        </tr>
        <tr>
            <td></td>
            <td><pre>/* Query 2 */ 
INSERT INTO users VALUES ( 3, 'Bob', 27 );
COMMIT;</pre></td>
        </tr>
        <tr>
            <td><pre>/* Query 1 */
SELECT * FROM users
WHERE age BETWEEN 10 AND 30;</pre></td>
            <td></td>
        </tr>
    </tbody>
</table>
	
在这个例子中，事务一执行了两次相同的查询操作。但是两次操作中间事务二向数据库中增加了一条符合事务一的查询条件的数据，导致幻读。

## 解决方案
要想解决脏读、不可重复读、幻读等读现象，那么就需要提高[事务隔离级别](#事物隔离级别)。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。


# 数据库的锁机制
> 数据库的读现象浅析中介绍过，在并发访问情况下，可能会出现脏读、不可重复读和幻读等读现象，为了应对这些问题，主流数据库都提供了锁机制，并引入了事务隔离级别的概念。

## 并发控制
> 在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。

数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。下面举例说明并发操作带来的数据不一致性问题：

现有两处火车票售票点，同时读取某一趟列车车票数据库中车票余额为 X。两处售票点同时卖出一张车票，同时修改余额为 X -1写回数据库，这样就造成了实际卖出两张火车票而数据库中的记录却只少了一张。 产生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。

封锁、时间戳、乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

## 锁
当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。

在计算机科学中，锁是在执行多线程时用于强行限制资源访问的同步机制，即用于在并发控制中保证对互斥要求的满足。

**锁的分类(oracle)**
- 按操作划分，可分为DML锁、DDL锁
- 按锁的粒度划分，可分为表级锁、行级锁、页级锁（mysql）
- 按锁级别划分，可分为共享锁、排他锁
- 按加锁方式划分，可分为自动锁、显示锁
- 按使用方式划分，可分为乐观锁、悲观锁

DML锁（data locks，数据锁），用于保护数据的完整性，其中包括行级锁(Row Locks (TX锁))、表级锁(table lock(TM锁))。 DDL锁（dictionary locks，数据字典锁），用于保护数据库对象的结构，如表、索引等的结构定义。其中包排他DDL锁（Exclusive DDL lock）、共享DDL锁（Share DDL lock）、可中断解析锁（Breakable parse locks）


# References

- [彻底理解数据库事务](http://www.hollischuang.com/archives/898)
- [数据库的读现象浅析](http://www.hollischuang.com/archives/900)
- [深入分析事务的隔离级别](https://www.hollischuang.com/archives/943)
- [数据库的锁机制](http://www.hollischuang.com/archives/909)
